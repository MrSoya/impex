    <!-- 
        1. 整个表格可以定义高度，可以不定义高度 √
        2. 如果需要表格固定表头，表格必须设置高度 √
        3. 表格每一列都可以改变宽度，总宽度改变后，出现横向滚动条
        4. 支持复杂表头 √
        5. 表格内容自动支持省略号显示 √
        6. 支持当前页排序
        7. 支持固定列，列可以在表格窗口两头固定，可以同时固定多列 √
        8. 如果表格尺寸发生改变，固定列需要根据宽度确定是否取消
    -->
    <!-- 视图  -->
    <template>
        <style>
        :host{
            flex-direction: column;
            position: relative;
            display: flex;
            overflow: hidden;
            
            color: #656565;
            background-color: #fff;
            /*width: 100%;*/

            /* test */
            
            /*height: 500px;*/
        }

        td,th{
            min-width: 50px;
        }

        header{
            overflow: hidden;
            color: #656565;
            background-color:#f5f5f5;
            border-bottom:1px solid #e7e7e7;
        }
        .body{
            flex: 1;
            display: flex;
            vertical-align: top;
            white-space: normal;
            position: relative;
            overflow: auto;
            /*border-right:1px solid #e7e7e7;*/
            background-color: #fff;
        }

        table{
            width: auto;
            max-width: none;
            border-style: solid;
            border-width: 0;
            border-collapse: separate;
            border-spacing: 0;
            empty-cells: show;
            outline: 0;
        }

        th,td{
            padding: 0 3px;
            line-height: 38px;
            border-style: solid;
            border-color: inherit;
            outline: 0;
            text-align: inherit;
            overflow: hidden;
            text-overflow: ellipsis;
            font-weight: inherit;
            border: 1px solid;
            border-width: 1px 1px 0 0;
            border-color:#e7e7e7;
        }
        header th.holder,header th.holder div{
            width: 17px;
            padding: 0;
            min-width: 0;
        }
        th>div,td>div{
            position: relative;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            box-sizing: border-box;
        }
        .body table tr:first-child td{
            border-top:none;
        }
        .body table tr td:last-child,
        .fixed-layer header table tr th:last-child{
            border-right:none;
        }

        .body iframe{
            position: absolute;
            left: 0;
            top: 0;
            border: none;
            width: 0;
            z-index: -1;
            height: 100%;
            overflow: hidden;
        }

        .fixed-layer{
            position: absolute;
            top: 0;
            box-shadow: 0 -1px 8px rgba(0,0,0,.08);
            box-sizing:border-box;
        }
        .fixed-layer.left{
            left: 0;
        }
        .fixed-layer.right{
            right: 0;
        }
    </style>
    <section .class="cls">
        <header ref="header">
            <table class="table" cellpadding="0" cellspacing="0">
                <tr x-for="header as row">
                    <th x-for="row as col" 
                    .rowspan="(col.group?0:(headerRowSize - col.rowNo+1)) || ''"
                    .colspan="col.colspan || ''"
                    .class="{holder:col.holder}"
                    .style="{display:col.holder?scrollable?'table-cell':'none':'table-cell'}"
                    :tap="_sortBy(col.field,col.group)">
                        <div .style="col.style">
                            {{col.name}}
                        </div>
                    </th>
                </tr>
            </table>
        </header>
        <div class="body" :scroll="syncScroll($event)" .style="{'border-right-width':scrollable?'1px':0}" ref="body">
            <iframe src="javascript:;" ref="iframe" ></iframe>
            <table ref="bodytable">
                <tr x-for="dataList as item =>orderBy:orderKey:orderDir">
                    <td x-for="fieldQ as field" 
                    .rowspan="item.rowspan || ''"
                    .colspan="item.colspan || ''">
                        <div .style="field[1]">{{item[field[0]]}}</div>
                    </td>
                </tr>
            </table>
        </div>
        <div class="fixed-layer left">
            <header>
                <table class="table" cellpadding="0" cellspacing="0" style="height: 100%">
                    <tr x-for="header as row">
                        <th x-for="row as col" x-if="col.locked"
                        .rowspan="(col.group?0:(headerRowSize - col.rowNo+1)) || ''"
                        .colspan="col.colspan || ''"
                        .class="{holder:col.holder}"
                        .style="{display:col.holder?scrollable?'table-cell':'none':'table-cell'}"
                        :tap="_sortBy(col.field,col.group)">
                            <div .style="col.style">
                                {{col.name}}
                            </div>
                        </th>
                    </tr>
                </table>
            </header>
            <div class="body" style="overflow: hidden;border-right: 0;" :wheel="syncWheel($event)">
                <table>
                    <tr x-for="dataList as item =>orderBy:orderKey:orderDir">
                        <td x-for="fieldQ as field" x-if="field[2]"
                        .rowspan="item.rowspan || ''"
                        .colspan="item.colspan || ''">
                            <div .style="field[1]">{{item[field[0]]}}</div>
                        </td>
                    </tr>
                </table>
            </div>
        </div>
    </section>
</template>
<!-- 模型  -->
<script type="text/javascript" id="impex">
    function component(){
        function immutable(obj){
            return JSON.parse(JSON.stringify(obj));
        }

        return {
            state:{
                scrollable:false,
                cls:'',
                orderKey:'',
                orderDir:''
            },
            onPropBind:function(props){
                //以行为单位，生成表头
                var header = [],
                lockedHeader = [];
                header.rowSize = 0;
                var fieldQ = [],
                lockedFieldQ = [];
                this.getHeaderRows(fieldQ,header,lockedFieldQ,lockedHeader,props.dataHeader,header.rowSize+1);
                header[1].push({rowNo:1,name:'&nbsp;',holder:true});
                
                this.state.header = header;

                this.state.lockedHeader = lockedHeader;
                this.state.headerRowSize = header.rowSize;
                this.state.dataList = props.dataList;
                this.state.fieldQ = fieldQ;
                this.state.lockedFieldQ = lockedFieldQ;

                this.state.cls = props.class;
            },
            onBeforeMount:function(dom){
                
            },
            onMount:function(){
                var that = this;
                this.refs.iframe.contentWindow.onresize = function(){
                    that.syncSize();
                }
                var body = this.refs.body;
                var ch = body.clientHeight,
                    oh = body.offsetHeight;
                if(ch != oh){
                    this.state.scrollable = true;
                }

                var hh = this.refs.header.firstElementChild.offsetHeight;
                var headers = document.querySelectorAll('.fixed-layer>header');
                for(var i=headers.length;i--;){
                    headers[i].style.height = hh + 'px';
                }

                var bodys = document.querySelectorAll('.fixed-layer>.body');
                for(var i=bodys.length;i--;){
                    bodys[i].style.height = body.clientHeight + 'px';
                }
            },
            getHeaderRows:function(fieldQ,header,lockedFieldQ,lockedHeader,ds,rowSize){
                var rows = header[rowSize];
                var lockedRows = lockedHeader[rowSize];
                if(!rows){
                    header[rowSize] = rows = [];
                    lockedHeader[rowSize] = lockedRows = [];
                }
                
                var rowNo = header.rowSize = rowSize;
                var colSize = 0;
                //group为新行
                for(var i=0;i<ds.length;i++){
                    //直接修改父组件的引用会导致父组件触发update，然后又触发子组件的onPropChange，然后又触发子组件的update重绘，出现问题
                    var col = immutable(ds[i]);
                    if(col.group){
                        var tmpCols = [];

                        var tmp = this.getHeaderRows(fieldQ,header,lockedFieldQ,lockedHeader,col.children,rowSize+1);
                        colSize += tmp;
                        col.rowNo = rowNo;
                        col.colspan = tmp;
                    }else{
                        colSize++;
                        if(col.locked){
                            lockedFieldQ.push([col.field,col.style||'']);
                        }
                        fieldQ.push([col.field,col.style||'',col.locked]);
                        
                    }
                    col.rowNo = rowNo;//所在行号，用来计算非group的rowspan
                    if(col.locked){
                        lockedRows.push(col);
                    }
                    rows.push(col);
                }
                
                return colSize;
            },
            syncWheel:function(e){
                var body = this.refs.body;
                var st = body.scrollTop;
                var dy = e.deltaY;
                var direction = dy>0 ? 1 : -1;
                st += 100*direction;
                
                e.target.scrollTop = body.scrollTop = st;
            },
            syncScroll:function(e){
                var header = this.refs.header;
                var st = header.scrollTop;
                var sl = header.scrollLeft;
                var tsl = e.target.scrollLeft;
                var tst = e.target.scrollTop;
                header.scrollLeft = tsl;
                var bodys = document.querySelectorAll('.fixed-layer>.body');
                for(var i=bodys.length;i--;){
                    bodys[i].scrollTop = tst;
                }
            },
            syncSize:function() {
                // body...
            },
            sortDir:{},
            _sortBy:function(key,isGroup) {
                if(isGroup)return;
                this.state.orderKey = key;
                var lastDir = this.sortDir[key]||'';
                switch(lastDir){
                    case '':
                        this.sortDir[key] = 'asc';break;
                    case 'asc':
                        this.sortDir[key] = 'desc';break;
                    case 'desc':
                        this.sortDir[key] = '';
                        this.state.orderKey = '';
                        break;
                }
                console.log(key,this.sortDir[key])

                this.state.orderDir = this.sortDir[key];
            }
        };
    }
    </script>